# -*- coding: utf-8 -*-
"""
Created on Fri May 15 10:22:28 2015

@author: georg
"""

""" a collection of IO tools that are compatible with the .lst / .gloDatamix
file specifications by C.Giovanni Galizia 

io is designed useable by ILTIS interface as well as programmatically
"""


import scipy as sp
import pandas as pd
import os
import re
import time

def read_lst(lst_path):
    """ reads the .lst file at lst_path to a pd.DataFrame """
    LSTdata = pd.read_csv(lst_path,header=0,delimiter='\t')
                
    # remove the weird random amount of whitespaces in the column names
    columns = []

    for col in LSTdata.columns:
        columns.append(col.strip())
        pass
    
    LSTdata.columns = columns
    return LSTdata


def read_gloDatamix(path,nTags=None,tagList=None):
    """ reads a .gloDatamix file and puts the metadata into a pd.Dataframe and
    the numerical data into a np.array.
    Data is a flat 2d representation of nROI*nMeasurements x time, the order in 
    the first dim is cycle first through ROIs and then through measurements """
    
    # read line by line
    fh = open(path,'r')
    lines = fh.readlines()


    if tagList == None:
        if nTags == None:
            # infer nTags
            nTags = sp.sum([field[:4] != 'data' for field in lines[0].strip().split('\t')]) # this breaks with Ana style gloDatamix
    
    # read data into np.array and medadata into pd.DataFrame
    Data = sp.zeros((len(lines)-1,len(lines[0].split('\t')) - nTags))
    
    for i,line in enumerate(lines):
        if i == 0:
            tags = line.split('\t')[:nTags]
            Meta = pd.DataFrame(columns = tags, index=range(len(lines)-1))
        else:
            meta = line.split('\t')[:nTags]
            Meta.iloc[i-1] = meta
            Data[i-1,:] = sp.array(line.split('\t')[nTags:],dtype='float32')
        
    return Meta, Data


def write_gloDatamix(Meta,Data,outpath):
    """ creates a .gloDatamix from the metadata (pd.Dataframe) and data
    (np.array) in the format that they were generated by the read_gloDatamix()
    function """
    
    labels = '\t'.join(Meta.columns.tolist() + ['data'+ str(number) for number in range(Data.shape[1])]) # this generates a "real" glodatamix header
    
    fh = open(outpath,'w')
    fh.write(labels)
    fh.write('\n')
    
    for i in range(Data.shape[0]):
        metainfo = Meta.loc[i].tolist()
        data = Data[i,:].astype('S20').tolist()
        values = '\t'.join(metainfo + data)

        fh.write(values)
        fh.write('\n')
    fh.close()

def log2lst(fname):
    """ converts a till photonics .vws.log into a lst. Function is not split into
    read and write because that is never needed """
    
    # some constants and declarations
    block_starts = []
    block_names = []
    read_length = 18 # const
    lst_labels = ["Measu","Label","Odour","DBB1","Cycle","MTime","OConc","Control","StimON","StimOFF","Pharma","PhTime","PhConc","Comment","ShiftX","ShiftY","StimISI","setting","dbb2","dbb3","PxSzX","PxSzY","PosZ","Lambda","Countl","slvFlip","Stim2ON","Stim2OFF","Age","Analyze"]
    last_time = 0
    lst_fname = os.path.splitext(os.path.splitext(fname)[0])[0] + '.lst' # removes both .vws and .log
    
    # read log and parse
    with open(fname, 'r') as fh:
        lines = [line.strip() for line in fh.readlines()]
    
    for i,line in enumerate(lines):
        match = re.search('^\[(.*)\]',line)
        if match:
            block_starts.append(i)
            block_names.append(match.group(1))
            
    valid_blocks = []
    for i,name in enumerate(block_names):
        if name.count('Snapshot') > 0 or name.count('Delta') > 0:
            pass
        else:
            valid_blocks.append([i,block_starts[i],name])
    
    Measurements = []
    for i,block_info in enumerate(valid_blocks):
        Measurements.append({'index':block_info[0],'label':block_info[2]})
        
        ind = block_info[1]
        block = lines[ind+1:ind+read_length]
    
        for line in block:
            line_split = line.split(':')
            if len(line_split) == 2:
                key,value = line_split
            if len(line_split) > 2:
                key = line_split[0]
                value = ':'.join(line_split[1:]).strip()
            Measurements[i][key] = value
    
    # loop and write
    lst_handle = open(lst_fname,'w')  
    lst_handle.write('\t'.join(lst_labels))
    
    for Measurement in Measurements:
        label_split = Measurement['label'].split('_')
        if len(label_split) == 5:
            tmp, Odour, OConc, tmp, tmp = label_split
        if len(label_split) == 3:
            setting,Odour,OConc = label_split
        if len(label_split) == 2:
            setting,OConc = label_split
            Odour = 'Missing'
        else:
            setting = Measurement['label']
            Odour = 'Missing'
            OConc = '0'
    
        # time
        """ it is unclear what mtime is exactly supposed to be. In this calc, there
        is some kind of bug, leaving a 1s approx offst """
        try:
            times = Measurement['timing [ms]'].strip()
            times = sp.array(times.split(' '),dtype='int32')
            times_hhmmss = [time.strftime('%H:%M:%S',time.gmtime((t+last_time)/1000.0)) for t in times]
            last_time = times[-1] + last_time
            mtime = times_hhmmss[len(times)/2]
            dt = str(sp.diff(times)[0])
        except:
            mtime = '-1'
            dt = '-1'
    
        # location, check if pst, else -1
        ext = os.path.splitext(Measurement['Location'])[1]
        if ext != '.pst':
            Location = '-1'
        else:
            tanimal = os.path.splitext(os.path.splitext(os.path.basename(fname))[0])[0] # tanimal
            dbb = os.path.splitext(Measurement['Location'].split('\\')[-1])[0] # dbb wo pst
            Location = '\\'.join([tanimal + '.pst',dbb])
            
        # Countl
        Countl = 'subloop,\''+str(Measurement['index']+1)+'\';  '+Measurement['label']
        
        Measu = str(Measurement['index']+1)
        Label = Measurement['label']
        Odour = Odour
        DBB1 = Location
        Cycle = dt
        MTime = mtime
        OConc = OConc
        Control = '0'
        StimON = '24'
        StimOFF = '28'
        Pharma = 'Ringer'
        PhTime = mtime
        PhConc = '0'
        Comment = 'log2lst.py'
        ShiftX = '0'
        ShiftY = '0'
        StimISI = '0'
        setting = setting
        dbb2 = 'noDBB2'
        dbb3 = 'noDBB3'
        PxSzX = '1.57'
        PxSzY = '1.57'
        PosZ = '0'
        Lambda = Measurement['Monochromator wavelength [nm]'].strip()
        Countl = Countl
        slvFlip = '0'
        Stim2ON = '36'
        Stim2OFF = '40'
        Age = '-1'
        Analyze = '2'
        
        values = '\t'.join([Measu,Label,Odour,DBB1,Cycle,MTime,OConc,Control,StimON,StimOFF,Pharma,PhTime,PhConc,Comment,ShiftX,ShiftY,StimISI,setting,dbb2,dbb3,PxSzX,PxSzY,PosZ,Lambda,Countl,slvFlip,Stim2ON,Stim2OFF,Age,Analyze])
        lst_handle.write('\n')
        lst_handle.write(values)
        
    lst_handle.close()
    

        


        
if __name__ == '__main__':
    # for some testing purposes ...
    lst_path = '/home/georg/python/ILTIS/testdata/2015_11_Iltis_PN_TillVision/ps081202c_orig.lst'
    lst_data = read_lst(lst_path)
